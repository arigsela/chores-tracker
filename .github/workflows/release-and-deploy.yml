name: Release and Deploy

on:
  workflow_dispatch:
    inputs:
      release_type:
        description: 'Release type'
        required: true
        default: 'minor'
        type: choice
        options:
          - patch
          - minor
          - major
          - custom
      version:
        description: 'Version (only required for custom release type)'
        required: false
        type: string
      release_notes:
        description: 'Release notes (optional - will auto-generate if empty)'
        required: false
        type: string
      skip_deploy:
        description: 'Skip Docker build and ECR deployment'
        required: false
        type: boolean
        default: false

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}

permissions:
  contents: write
  issues: read
  pull-requests: read
  id-token: write

jobs:
  release-and-deploy:
    name: Create Release and Deploy to ECR
    runs-on: ubuntu-latest
    environment: production
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Validate inputs
        run: |
          RELEASE_TYPE="${{ github.event.inputs.release_type }}"
          VERSION="${{ github.event.inputs.version }}"
          
          echo "Release type: $RELEASE_TYPE"
          
          if [[ "$RELEASE_TYPE" == "custom" ]]; then
            if [[ -z "$VERSION" ]]; then
              echo "::error::Version is required when release type is 'custom'"
              exit 1
            fi
            
            if ! [[ "$VERSION" =~ ^[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
              echo "::error::Version must be in format X.Y.Z (e.g., 1.0.0)"
              exit 1
            fi
            echo "Custom version provided: $VERSION"
          else
            if [[ -n "$VERSION" ]]; then
              echo "::warning::Version input is ignored for $RELEASE_TYPE release type"
            fi
            echo "Version will be calculated automatically based on $RELEASE_TYPE"
          fi
          
          echo "RELEASE_TYPE=$RELEASE_TYPE" >> "$GITHUB_ENV"

      - name: Get latest tag
        id: get_latest_tag
        run: |
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          echo "Latest tag: $LATEST_TAG"
          echo "latest_tag=$LATEST_TAG" >> "$GITHUB_OUTPUT"

      - name: Calculate next version
        id: calc_version
        run: |
          if [[ "${{ github.event.inputs.release_type }}" == "custom" ]]; then
            NEW_VERSION="v${{ github.event.inputs.version }}"
          else
            LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
            LATEST_TAG=${LATEST_TAG#v}
            
            IFS='.' read -r MAJOR MINOR PATCH <<< "$LATEST_TAG"
            MAJOR=${MAJOR:-0}
            MINOR=${MINOR:-0}
            PATCH=${PATCH:-0}
            
            case "${{ github.event.inputs.release_type }}" in
              major)
                NEW_VERSION="v$((MAJOR + 1)).0.0"
                ;;
              minor)
                NEW_VERSION="v${MAJOR}.$((MINOR + 1)).0"
                ;;
              patch)
                NEW_VERSION="v${MAJOR}.${MINOR}.$((PATCH + 1))"
                ;;
            esac
          fi
          
          echo "New version: $NEW_VERSION"
          
          # Extract version components for Docker tags
          VERSION_NUMBER=${NEW_VERSION#v}
          IFS='.' read -r MAJOR MINOR PATCH <<< "$VERSION_NUMBER"
          
          {
            echo "new_version=$NEW_VERSION"
            echo "new_version_number=${NEW_VERSION#v}"
            echo "major=$MAJOR"
            echo "minor=$MINOR"
            echo "patch=$PATCH"
          } >> "$GITHUB_OUTPUT"
          
          if git rev-parse "$NEW_VERSION" >/dev/null 2>&1; then
            echo "::error::Tag $NEW_VERSION already exists"
            exit 1
          fi

      - name: Generate release notes
        id: generate_notes
        run: |
          NEW_VERSION="${{ steps.calc_version.outputs.new_version }}"
          LATEST_TAG="${{ steps.get_latest_tag.outputs.latest_tag }}"
          
          if [[ -n "${{ github.event.inputs.release_notes }}" ]]; then
            NOTES="${{ github.event.inputs.release_notes }}"
          else
            {
              echo "## What's Changed"
              echo ""
              
              if [[ "$LATEST_TAG" != "v0.0.0" ]]; then
                git log --pretty=format:"* %s (%an)" "$LATEST_TAG"..HEAD
              else
                git log --pretty=format:"* %s (%an)"
              fi
              
              echo ""
              echo ""
              echo "**Full Changelog**: https://github.com/${{ github.repository }}/compare/$LATEST_TAG...$NEW_VERSION"
            } > release_notes.md
            
            NOTES=$(cat release_notes.md)
          fi
          
          echo "$NOTES" > release_notes_final.md

      - name: Check if AWS secrets are configured
        id: check-secrets
        if: ${{ github.event.inputs.skip_deploy != 'true' }}
        run: |
          if [[ -z "${{ secrets.AWS_ACCESS_KEY_ID }}" ]] || [[ -z "${{ secrets.AWS_SECRET_ACCESS_KEY }}" ]] || [[ -z "${{ secrets.ECR_REPOSITORY }}" ]]; then
            echo "::warning::AWS secrets not configured. Skipping ECR deployment."
            echo "configured=false" >> "$GITHUB_OUTPUT"
          else
            echo "configured=true" >> "$GITHUB_OUTPUT"
          fi

      - name: Configure AWS credentials
        if: steps.check-secrets.outputs.configured == 'true' && github.event.inputs.skip_deploy != 'true'
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        if: steps.check-secrets.outputs.configured == 'true' && github.event.inputs.skip_deploy != 'true'
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2
        with:
          mask-password: true

      - name: Set up Docker Buildx
        if: steps.check-secrets.outputs.configured == 'true' && github.event.inputs.skip_deploy != 'true'
        uses: docker/setup-buildx-action@v3

      - name: Build and push Docker image
        if: steps.check-secrets.outputs.configured == 'true' && github.event.inputs.skip_deploy != 'true'
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64
          push: true
          tags: |
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.calc_version.outputs.new_version_number }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.calc_version.outputs.major }}.${{ steps.calc_version.outputs.minor }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:${{ steps.calc_version.outputs.major }}
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:latest
            ${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}:sha-${{ github.sha }}
          build-args: |
            BUILD_VERSION=${{ steps.calc_version.outputs.new_version }}
            BUILD_DATE=$(date -u +%Y-%m-%dT%H:%M:%SZ)

      - name: Create and push tag
        run: |
          NEW_VERSION="${{ steps.calc_version.outputs.new_version }}"
          
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          
          git tag -a "$NEW_VERSION" -m "Release $NEW_VERSION"
          git push origin "$NEW_VERSION"

      - name: Create GitHub Release
        uses: actions/create-release@v1
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ steps.calc_version.outputs.new_version }}
          release_name: Release ${{ steps.calc_version.outputs.new_version }}
          body_path: release_notes_final.md
          draft: false
          prerelease: false

      - name: Summary
        run: |
          NEW_VERSION="${{ steps.calc_version.outputs.new_version }}"
          {
            echo "## Release Created Successfully! ðŸŽ‰"
            echo ""
            echo "**Version:** $NEW_VERSION"
            echo "**Release URL:** https://github.com/${{ github.repository }}/releases/tag/$NEW_VERSION"
            echo ""
            
            if [[ "${{ steps.check-secrets.outputs.configured }}" == "true" ]] && [[ "${{ github.event.inputs.skip_deploy }}" != "true" ]]; then
              echo "### Docker Image Tags Created"
              echo "- \`${{ steps.calc_version.outputs.new_version_number }}\` (full version)"
              echo "- \`${{ steps.calc_version.outputs.major }}.${{ steps.calc_version.outputs.minor }}\` (major.minor)"
              echo "- \`${{ steps.calc_version.outputs.major }}\` (major only)"
              echo "- \`latest\`"
              echo "- \`sha-${{ github.sha }}\`"
              echo ""
              echo "**Registry:** \`${{ steps.login-ecr.outputs.registry }}/${{ env.ECR_REPOSITORY }}\`"
              echo "**Image Digest:** \`${{ steps.build.outputs.digest }}\`"
            else
              echo "### Docker Deployment"
              echo "âš ï¸ Docker image deployment was skipped"
              if [[ "${{ github.event.inputs.skip_deploy }}" == "true" ]]; then
                echo "Reason: Manually skipped via workflow input"
              else
                echo "Reason: AWS credentials not configured"
              fi
            fi
          } >> "$GITHUB_STEP_SUMMARY"